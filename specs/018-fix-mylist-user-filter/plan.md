# Implementation Plan: Fix My Restaurant List User Filter

**Branch**: `018-fix-mylist-user-filter` | **Date**: 2026-02-22 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/018-fix-mylist-user-filter/spec.md`

## Summary

The main page ('나의 맛집' tab) shows all users' restaurant data because the read hooks in `src/db/hooks.ts` lack a `.eq("user_id", userId)` filter. The fix adds user-scoped filtering to five hooks by obtaining the current user's ID via `supabase.auth.getUser()` inside each query function — matching the pattern already used by profile-hooks and mutation hooks.

## Technical Context

**Language/Version**: TypeScript 5.x (strict mode)
**Primary Dependencies**: Next.js 16 (App Router), React 19, Supabase JS Client (@supabase/ssr)
**Storage**: Supabase Postgres (existing `restaurants` table with `user_id` column)
**Testing**: Vitest + React Testing Library (unit tests in `tests/unit/`)
**Target Platform**: Mobile-first web (all modern browsers)
**Project Type**: Web application (Next.js App Router)
**Performance Goals**: No regression — queries add one WHERE clause to existing indexed column
**Constraints**: No schema or RLS changes; must not break social profile cross-user reads
**Scale/Scope**: 1 file modified (`src/db/hooks.ts`), 1 test file added/updated

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Code Quality | PASS | Single-responsibility maintained; no dead code introduced |
| II. Testing Standards | PASS | Unit tests will verify user_id filter is applied; test-first approach |
| III. UX Consistency | PASS | No UI changes; fix restores expected behavior |
| IV. Performance | PASS | Adding `.eq("user_id", userId)` on an indexed FK column — no degradation |
| V. Simplicity | PASS | Minimal change; reuses existing auth pattern from mutation hooks |

**Post-Design Re-check**: All gates still pass. No new dependencies, no schema changes, no abstractions introduced.

## Project Structure

### Documentation (this feature)

```text
specs/018-fix-mylist-user-filter/
├── plan.md              # This file
├── research.md          # Root cause analysis and design decisions
├── data-model.md        # Schema reference (no changes needed)
├── quickstart.md        # Implementation guide
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (files affected)

```text
src/
└── db/
    └── hooks.ts              # Add .eq("user_id", userId) to 5 read hooks

tests/
└── unit/
    └── hooks-user-filter.test.ts  # New: verify user_id filtering
```

**Structure Decision**: Existing Next.js App Router project. Only `src/db/hooks.ts` is modified. No new modules or abstractions needed.

## Design: Hooks Modification

### Affected Hooks (all in `src/db/hooks.ts`)

| Hook | Current Behavior | Fix |
|------|-----------------|-----|
| `useVisitedGrouped()` | Returns all users' visited restaurants | Add `.eq("user_id", userId)` via inline auth |
| `useWishlistGrouped()` | Returns all users' wishlist items | Add `.eq("user_id", userId)` via inline auth |
| `useWishlist()` | Returns all users' restaurants | Add `.eq("user_id", userId)` via inline auth |
| `useRestaurant(placeId)` | Returns any user's restaurant | Add `.eq("user_id", userId)` — scoped to current user's copy |
| `useIsWishlisted(placeId)` | Checks if any user saved the place | Add `.eq("user_id", userId)` — check only current user |

### Implementation Pattern

Each hook's query function will:
1. Call `supabase.auth.getUser()` to get the current user
2. If no user, return empty result (consistent with unauthenticated state)
3. Add `.eq("user_id", user.id)` to the query chain

This matches the existing pattern in `useAddRestaurant()` (line 126-129 of hooks.ts).

### Cache Key Strategy

Cache keys remain unchanged (`restaurants:visited`, `restaurants:wishlist`, etc.) because:
- `invalidateRestaurants()` already invalidates these exact keys
- The main page always shows current user data, so user-specific cache keys are unnecessary
- If the user logs out and back in as a different user, the auth state change should trigger a re-render

## Complexity Tracking

No constitution violations. No complexity tracking needed.
